"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1636],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),u=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=u(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),d=u(n),m=r,f=d["".concat(p,".").concat(m)]||d[m]||c[m]||l;return n?a.createElement(f,i(i({ref:t},s),{},{components:n})):a.createElement(f,i({ref:t},s))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=d;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4717:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>i,default:()=>s,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=n(3117),r=(n(7294),n(3905));const l={sidebar_label:"function_utils",title:"function_utils"},i=void 0,o={unversionedId:"reference/function_utils",id:"reference/function_utils",isDocsHomePage:!1,title:"function_utils",description:"get\\typed\\annotation",source:"@site/docs/reference/function_utils.md",sourceDirName:"reference",slug:"/reference/function_utils",permalink:"/autogen/docs/reference/function_utils",editUrl:"https://github.com/microsoft/autogen/edit/main/website/docs/reference/function_utils.md",tags:[],version:"current",frontMatter:{sidebar_label:"function_utils",title:"function_utils"},sidebar:"referenceSideBar",previous:{title:"code_utils",permalink:"/autogen/docs/reference/code_utils"},next:{title:"math_utils",permalink:"/autogen/docs/reference/math_utils"}},p=[{value:"get_typed_annotation",id:"get_typed_annotation",children:[],level:4},{value:"get_typed_signature",id:"get_typed_signature",children:[],level:4},{value:"get_typed_return_annotation",id:"get_typed_return_annotation",children:[],level:4},{value:"get_param_annotations",id:"get_param_annotations",children:[],level:4},{value:"Parameters Objects",id:"parameters-objects",children:[],level:2},{value:"Function Objects",id:"function-objects",children:[{value:"get_parameter_json_schema",id:"get_parameter_json_schema",children:[],level:4},{value:"get_required_params",id:"get_required_params",children:[],level:4},{value:"get_default_values",id:"get_default_values",children:[],level:4},{value:"get_parameters",id:"get_parameters",children:[],level:4},{value:"get_missing_annotations",id:"get_missing_annotations",children:[],level:4},{value:"get_function_schema",id:"get_function_schema",children:[],level:4},{value:"get_load_param_if_needed_function",id:"get_load_param_if_needed_function",children:[],level:4},{value:"load_basemodels_if_needed",id:"load_basemodels_if_needed",children:[],level:4}],level:2}],u={toc:p};function s(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h4",{id:"get_typed_annotation"},"get","_","typed","_","annotation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_typed_annotation(annotation: Any, globalns: Dict[str, Any]) -> Any\n")),(0,r.kt)("p",null,"Get the type annotation of a parameter."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"annotation")," - The annotation of the parameter"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"globalns")," - The global namespace of the function")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  The type annotation of the parameter"),(0,r.kt)("h4",{id:"get_typed_signature"},"get","_","typed","_","signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_typed_signature(call: Callable[..., Any]) -> inspect.Signature\n")),(0,r.kt)("p",null,"Get the signature of a function with type annotations."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"call")," - The function to get the signature for")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  The signature of the function with type annotations"),(0,r.kt)("h4",{id:"get_typed_return_annotation"},"get","_","typed","_","return","_","annotation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_typed_return_annotation(call: Callable[..., Any]) -> Any\n")),(0,r.kt)("p",null,"Get the return annotation of a function."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"call")," - The function to get the return annotation for")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  The return annotation of the function"),(0,r.kt)("h4",{id:"get_param_annotations"},"get","_","param","_","annotations"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_param_annotations(\n    typed_signature: inspect.Signature\n) -> Dict[int, Union[Annotated[Type, str], Type]]\n")),(0,r.kt)("p",null,"Get the type annotations of the parameters of a function"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"typed_signature")," - The signature of the function with type annotations")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A dictionary of the type annotations of the parameters of the function"),(0,r.kt)("h2",{id:"parameters-objects"},"Parameters Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Parameters(BaseModel)\n")),(0,r.kt)("p",null,"Parameters of a function as defined by the OpenAI API"),(0,r.kt)("h2",{id:"function-objects"},"Function Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Function(BaseModel)\n")),(0,r.kt)("p",null,"A function as defined by the OpenAI API"),(0,r.kt)("h4",{id:"get_parameter_json_schema"},"get","_","parameter","_","json","_","schema"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_parameter_json_schema(\n        k: str, v: Union[Annotated[Type, str], Type],\n        default_values: Dict[str, Any]) -> JsonSchemaValue\n")),(0,r.kt)("p",null,"Get a JSON schema for a parameter as defined by the OpenAI API"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k")," - The name of the parameter"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"v")," - The type of the parameter"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default_values")," - The default values of the parameters of the function")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A Pydanitc model for the parameter"),(0,r.kt)("h4",{id:"get_required_params"},"get","_","required","_","params"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_required_params(typed_signature: inspect.Signature) -> List[str]\n")),(0,r.kt)("p",null,"Get the required parameters of a function"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"signature")," - The signature of the function as returned by inspect.signature")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A list of the required parameters of the function"),(0,r.kt)("h4",{id:"get_default_values"},"get","_","default","_","values"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_default_values(typed_signature: inspect.Signature) -> Dict[str, Any]\n")),(0,r.kt)("p",null,"Get default values of parameters of a function"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"signature")," - The signature of the function as returned by inspect.signature")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A dictionary of the default values of the parameters of the function"),(0,r.kt)("h4",{id:"get_parameters"},"get","_","parameters"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_parameters(required: List[str],\n                   param_annotations: Dict[str, Union[Annotated[Type, str],\n                                                      Type]],\n                   default_values: Dict[str, Any]) -> Parameters\n")),(0,r.kt)("p",null,"Get the parameters of a function as defined by the OpenAI API"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"required")," - The required parameters of the function"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"hints")," - The type hints of the function as returned by typing.get_type_hints")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A Pydantic model for the parameters of the function"),(0,r.kt)("h4",{id:"get_missing_annotations"},"get","_","missing","_","annotations"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_missing_annotations(typed_signature: inspect.Signature,\n                            required: List[str]) -> Tuple[Set[str], Set[str]]\n")),(0,r.kt)("p",null,"Get the missing annotations of a function"),(0,r.kt)("p",null,"Ignores the parameters with default values as they are not required to be annotated, but logs a warning."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"typed_signature")," - The signature of the function with type annotations"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"required")," - The required parameters of the function")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A set of the missing annotations of the function"),(0,r.kt)("h4",{id:"get_function_schema"},"get","_","function","_","schema"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_function_schema(f: Callable[..., Any],\n                        *,\n                        name: Optional[str] = None,\n                        description: str) -> Dict[str, Any]\n")),(0,r.kt)("p",null,"Get a JSON schema for a function as defined by the OpenAI API"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"f")," - The function to get the JSON schema for"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name")," - The name of the function"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"description")," - The description of the function")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A JSON schema for the function"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TypeError")," - If the function is not annotated")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"```\ndef f(a: Annotated[str, \"Parameter a\"], b: int = 2, c: Annotated[float, \"Parameter c\"] = 0.1) -> None:\n    pass\n\nget_function_schema(f, description=\"function f\")\n\n#   {'type': 'function',\n#    'function': {'description': 'function f',\n#        'name': 'f',\n#        'parameters': {'type': 'object',\n#           'properties': {'a': {'type': 'str', 'description': 'Parameter a'},\n#               'b': {'type': 'int', 'description': 'b'},\n#               'c': {'type': 'float', 'description': 'Parameter c'}},\n#           'required': ['a']}}}\n    ```\n")),(0,r.kt)("h4",{id:"get_load_param_if_needed_function"},"get","_","load","_","param","_","if","_","needed","_","function"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_load_param_if_needed_function(\n        t: Any) -> Optional[Callable[[T, Type], BaseModel]]\n")),(0,r.kt)("p",null,"Get a function to load a parameter if it is a Pydantic model"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"t")," - The type annotation of the parameter")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A function to load the parameter if it is a Pydantic model, otherwise None"),(0,r.kt)("h4",{id:"load_basemodels_if_needed"},"load","_","basemodels","_","if","_","needed"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def load_basemodels_if_needed(func: Callable[..., Any]) -> Callable[..., Any]\n")),(0,r.kt)("p",null,"A decorator to load the parameters of a function if they are Pydantic models"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"func")," - The function with annotated parameters")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A function that loads the parameters before calling the original function"))}s.isMDXComponent=!0}}]);